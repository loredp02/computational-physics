    
#include <iostream>
#include "stdlib.h"
#include "math.h"
#include <fstream>          
#include <cmath>
#include <vector>
#define FUNC(x) ((*func)(x))
#define nMAX 15

// Quello che faremo è andare ad implementare un metodo aperto da usare su un piccolo intervallo attorno a 0, dove la funzione esplode (l'estremo superiore
// sarà fissato in funzione di NMAX;), a quel punto nel resto dell'intervallo useremo i metodi chiusi.  

using namespace std;

// Metodo aperto
    
double midpoint(double (*func)(double), double a, double b, int n){
    double x, tnm, sum, del, ddel;
    static double s;
    int it,j;

    if(n==1){
        return (s=(b-a)*FUNC(0.5*(a+b)));
    }
    else {
        for (it=1, j=1; j<n-1; j++) it *= 3;
        tnm = it;
        del = (b-a)/(3.0 * tnm);
        ddel = del + del;
        x = a + 0.5*del;
        sum = 0.0;
        for (j=1; j<=it;j++) {
            sum += FUNC(x);
            x += ddel;
            sum += FUNC(x);
            x += del;
        }
        s = (s+(b-a)*sum/tnm)/3.0;
    return s;
    }
}

// Metodo del trapezio 

double trapzd (double (*func)(double), double a, double b, int n){
    double x, tnm, sum, del;
    static double s;
    int it,j;

    if(n==1){ return (s = 0.5*(b-a)*(FUNC(a) + FUNC(b)));
    } else {
        for (it=1, j=1; j < n-1; j++) it <<= 1;
        tnm = it;
        del = (b-a)/tnm;
        x = a + (double) (1./2.)*del;
        for (sum=0.0, j=1; j<=it;j++,x+=del) sum += FUNC(x);
        s= (double) (1./2.) *(s+(b-a)*sum/tnm);  
        return s;
    }
}

// Metodo di Simpson

double qsimp(double (*func)(double), double a, double b, int n){
    int j;
    float s,st,ost=0.0,os=0.0;

    for (j=1;j<=n;j++) {
        st=trapzd(func,a,b,j);
        s=(4.0*st-ost)/3.0;
        os=s;
        ost=st;
    }

    return s;
}

// METODO DI ROMBERG

double romberg(double (*func)(double), double a, double b, int N) {
    double h[N+1], r[N+1][N+1];
    
    for (int i = 1; i < N + 1; ++i) {
        h[i] = (b - a) / pow(2, i - 1);
    }
    r[1][1] = h[1] / 2 * (func(a) + func(b));
    for (int i = 2; i < N + 1; ++i) {
        double coeff = 0;
        for (int k = 1; k <= pow(2, i - 2); ++k) {
            coeff += func(a + (2 * k - 1) * h[i]);
        }
        r[i][1] = 0.5 * (r[i - 1][1] + h[i - 1] * coeff);
    }
    
    for (int i = 2; i < N + 1; ++i) {
        for (int j = 2; j <= i; ++j) {
            r[i][j] = r[i][j - 1] + (r[i][j - 1] - r[i - 1][j - 1]) / (pow(4, j - 1) - 1);
        }
    }
    return r[N][N];
}

// METODI DI GAUSS, in questo caso HERMITTE E LAGUERRE
    
double gauss_laguerre(double (*func) (double), int n){

    vector<double> vec_x2 {5.85786437626904951182e-01, 3.41421356237309504876e+00};
    vector<double> vec_x4 {3.22547689619392311802e-01, 1.74576110115834657569e+00, 4.53662029692112798345e+00, 9.39507091230113312950e+00};
    vector<double> vec_x8 {1.70279632305100999786e-01, 9.03701776799379912170e-01, 2.25108662986613068929e+00, 4.26670017028765879378e+00,
                           7.04590540239346569719e+00, 1.07585160101809952241e+01, 1.57406786412780045781e+01, 2.28631317368892641052e+01};

    vector<double> vec_w2 {8.53553390593273762191e-01, 1.46446609406726237796e-01};
    vector<double> vec_w4 {6.03154104341633601660e-01, 3.57418692437799686640e-01, 3.88879085150053842740e-02, 5.39294705561327450102e-04};
    vector<double> vec_w8 {3.69188589341637529929e-01, 4.18786780814342956078e-01, 1.75794986637171805706e-01, 3.33434922612156515224e-02,
                           2.79453623522567252491e-03, 9.07650877335821310457e-05, 8.48574671627253154502e-07, 1.04800117487151038157e-09}; 
                        
    double res = 0.0;
    double sum = 0.0;

    if(n==2){
        for(int i = 0; i < n; i++){
            sum += vec_w2.at(i)*func(vec_x2.at(i));
        }
    }

    else if(n==4){
        for(int i = 0; i < n; i++){
        sum += vec_w4.at(i)*func(vec_x4.at(i));
        }
    }

    else if(n==8){
        for(int i = 0; i < n; i++){
        sum += vec_w8.at(i)*func(vec_x8.at(i));
        }
    }

    return sum;

};


double gauss_hermitte(double (*func) (double), int n){

    vector<double> vec_x2 {-7.07106781186547524382e-01, 7.07106781186547524382e-01};
    vector<double> vec_x4 {-1.65068012388578455585e+00, -5.24647623275290317900e-01, 5.24647623275290317900e-01, 1.65068012388578455585e+00};
    vector<double> vec_x8 {-2.93063742025724401920e+00, -1.98165675669584292584e+00, -1.15719371244678019474e+00, -3.81186990207322116844e-01,
                            3.81186990207322116844e-01, 1.15719371244678019474e+00, 1.98165675669584292584e+00, 2.93063742025724401920e+00};
    vector<double> vec_x100 {-13.4064873381449, -12.8237997494878, -12.3429642228596, -11.9150619431141, -11.521415400787, -11.1524043855851,
                            -10.8022607536847, -10.4671854213428, -10.1445099412928, -9.83226980777796, -9.52896582339011,
                            -9.23342089021916, -8.94468921732547, -8.66199616813451, -8.38469694041626,
                            -8.11224731116279, -7.84418238446082, -7.58010080785748, -7.31965282230453, -7.06253106024886,
                            -6.80846335285879, -6.55720703192153, -6.30854436111213, -6.0622788326143, -5.81823213520351,
                            -5.57624164932992, -5.33615836013836, -5.09784510508913, -4.86117509179121, -4.62603063578715, 
                            -4.39230207868268, -4.15988685513103, -3.92868868342767, -3.69861685931849, -3.46958563641858,
                            -3.24151367963101, -3.01432358033115, -2.78794142398198, -2.5622964023726,
                            -2.33732046390687, -2.11294799637118, -1.889115537427, -1.6657615087415,
                            -1.44282597021593, -1.22025039121895, -0.997977436098105, -0.775950761540145, 
                            -0.554114823591616, -0.332414692342231, -0.110795872422439,1.10795872422439482889e-01, 
                            3.32414692342231807054e-01, 5.54114823591616988249e-01, 7.75950761540145781976e-01,
                            9.97977436098105243902e-01, 1.22025039121895305882e+00, 1.44282597021593278768e+00, 1.66576150874150946983e+00,
                            1.88911553742700837153e+00, 2.11294799637118795206e+00, 2.33732046390687850509e+00, 2.56229640237260802502e+00,
                            2.78794142398198931316e+00, 3.01432358033115551667e+00, 3.24151367963101295043e+00, 3.46958563641858916968e+00,
                            3.69861685931849193984e+00, 3.92868868342767097205e+00, 4.15988685513103054019e+00, 4.39230207868268401677e+00,
                            4.62603063578715577309e+00, 4.86117509179121020995e+00, 5.09784510508913624692e+00, 5.33615836013836049734e+00,
                            5.57624164932992410311e+00, 5.81823213520351704715e+00, 6.06227883261430263882e+00, 6.30854436111213512156e+00,
                            6.55720703192153931598e+00, 6.80846335285879641431e+00, 7.06253106024886543766e+00, 7.31965282230453531632e+00,
                            7.58010080785748888415e+00, 7.84418238446082116862e+00, 8.11224731116279191689e+00, 8.38469694041626507474e+00,
                            8.66199616813451771409e+00, 8.94468921732547447845e+00, 9.23342089021916155069e+00, 9.52896582339011480496e+00,
                            9.83226980777796909401e+00, 1.01445099412928454695e+01, 1.04671854213428121416e+01, 1.08022607536847145950e+01,
                            1.11524043855851252649e+01, 1.15214154007870302416e+01, 1.19150619431141658018e+01, 1.23429642228596742953e+01,
                            1.28237997494878089065e+01, 1.34064873381449101387e+01};

    vector<double> vec_w2 {8.86226925452758013655e-01, 8.86226925452758013655e-01};
    vector<double> vec_w4 {8.13128354472451771398e-02, 8.04914090005512836482e-01,  8.04914090005512836482e-01, 8.13128354472451771398e-02};
    vector<double> vec_w8 { 1.99604072211367619211e-04,  1.70779830074134754563e-02, 2.07802325814891879546e-01, 6.61147012558241291042e-01,
                            6.61147012558241291042e-01, 2.07802325814891879546e-01, 1.70779830074134754563e-02, 1.99604072211367619211e-04}; 
    vector<double> vec_w100 {5.90806786503120e-79, 1.97286057487945e-72, 3.08302899000327e-67, 9.01922230369355e-63,
                            8.51888308176163e-59, 3.45947793647555e-55, 7.19152946346337e-52, 8.59756395482527e-49,
                            6.42072520534847e-46, 3.18521787783591e-43, 1.10047068271422e-40, 2.74878488435711e-38,
                            5.11623260438522e-36, 7.27457259688776e-34, 8.06743427870937e-32, 7.10181222638493e-30,
                            5.03779116621318e-28, 2.91735007262933e-26, 1.39484152606876e-24, 5.56102696165916e-23, 
                            1.86499767513025e-21, 5.30231618313184e-20, 1.28683292112115e-18, 2.68249216476037e-17,
                            4.82983532170303e-16, 7.54889687791524e-15, 1.02887493735099e-13, 1.22787851441012e-12,
                            1.28790382573155e-11, 1.19130063492907e-10, 9.74792125387162e-10, 7.07585728388957e-09, 
                            4.56812750848493e-08, 2.62909748375372e-07, 1.35179715911036e-06, 6.22152481777786e-06,
                            2.56761593845490e-05, 9.51716277855096e-05, 3.17291971043300e-04, 9.52692188548619e-04,
                            2.57927326005909e-03, 6.30300028560805e-03, 1.39156652202318e-02, 2.77791273859335e-02, 
                            5.01758126774286e-02, 8.20518273912244e-02, 1.21537986844104e-01, 1.63130030502782e-01,
                            1.98462850254186e-01, 2.18892629587439e-01,2.18892629587439125060e-01, 1.98462850254186477710e-01, 1.63130030502782941425e-01, 1.21537986844104181985e-01,
                            8.20518273912244646789e-02, 5.01758126774286956964e-02, 2.77791273859335142698e-02, 1.39156652202318064178e-02,
                            6.30300028560805254921e-03, 2.57927326005909017346e-03, 9.52692188548619117497e-04, 3.17291971043300305539e-04,
                            9.51716277855096647040e-05, 2.56761593845490630553e-05, 6.22152481777786331722e-06, 1.35179715911036728661e-06,
                            2.62909748375372507934e-07, 4.56812750848493951350e-08, 7.07585728388957290740e-09, 9.74792125387162124528e-10, 
                            1.19130063492907294976e-10, 1.28790382573155823282e-11, 1.22787851441012497000e-12, 1.02887493735099254677e-13,
                            7.54889687791524329227e-15, 4.82983532170303334787e-16, 2.68249216476037608006e-17, 1.28683292112115327575e-18,
                            5.30231618313184868536e-20, 1.86499767513025225814e-21, 5.56102696165916731717e-23, 1.39484152606876708047e-24,
                            2.91735007262933241788e-26, 5.03779116621318778423e-28, 7.10181222638493422964e-30, 8.06743427870937717382e-32, 
                            7.27457259688776757460e-34, 5.11623260438522218054e-36, 2.74878488435711249209e-38, 1.10047068271422366943e-40,
                            3.18521787783591793076e-43, 6.42072520534847248278e-46, 8.59756395482527161007e-49, 7.19152946346337102982e-52, 
                            3.45947793647555044453e-55, 8.51888308176163378638e-59, 9.01922230369355617950e-63, 3.08302899000327481204e-67,
                            1.97286057487945255443e-72, 5.90806786503120681541e-79};

    double res = 0.0;
    double sum = 0.0;


    if(n==2){
        for(int i = 0; i < n; i++){
            sum += vec_w2.at(i)*func(vec_x2.at(i));
        }
    }

    else if(n==4){
        for(int i = 0; i < n; i++){
        sum += vec_w4.at(i)*func(vec_x4.at(i));
        }
    }

    else if(n==8){
        for(int i = 0; i < n; i++){
        sum += vec_w8.at(i)*func(vec_x8.at(i));
        // cout << "sum " << i << " " << sum << endl;
        }
    }

    else if(n==100){
        for(int i = 0; i < n; i++){
        sum += vec_w100.at(i)*func(vec_x100.at(i));
        }
    }

    return sum;

}
///////////////////////////////////////////////////////////////////////////////////////////////////7

// funzioni su cui operare

//funzione con il cambio di variabile
double func_change(double x){
    double y = 0.;
    y = pow((-log(x)),2);
    return y;
}

//funzione per gauss-laguerre
double func_lag(double x){
    double y = 0.;
    y = (pow((x+3), 5) * exp(-1.*(pow(x,2) + 5*x)));
    return y;
}

//funzinonI per gauss-Hermite
double func_herm(double x){
    double y = 0.;
    y = pow((fabs(x)+3),5)*exp(-6*fabs(x));
    return y;
}





int main ()
{   
    double a = 0.;
    double b = exp(-9);
    double TrueRes = 101/(2*exp(9));
    printf("Il risultato vero: %.16lf \n", TrueRes);

    double open_b = exp(-9)/nMAX; // andiamo a definire l'estremo superiore dell'intervallo in cui verrà applicato il metodo aperto

    int n = nMAX;

     ///////////////////////////////////////////////////////////////////////////////////////// TRAPEZIO
    double TrapezioRis = 0.0;
    TrapezioRis = (midpoint(func_change, a, open_b, n) + trapzd(func_change, open_b, b, n));
       
    cout << "Il risultato col trapezio: " << TrapezioRis << endl;

    ///////////////////////////////////////////////////////////////////////////////////////// SIMPSON
    double SimpsonRis = 0.0; //qsimp
    SimpsonRis = 0.5 * (midpoint(func_change, a, open_b, n) + qsimp(func_change, open_b, b, n));
        
    cout << "Il risultato con Simpson: " << SimpsonRis << endl;

    ///////////////////////////////////////////////////////////////////////////////////////// ROMBERG
    double RombergRis = 0.0; //romberg
    RombergRis = 0.5 * (midpoint(func_change, a, open_b, n) + romberg(func_change, open_b, b, n));

    cout << "Il risultato con Romberg: " << RombergRis  << endl;

   double gauss_herm2 = 0.0;
   double gauss_herm4 = 0.0;
   double gauss_herm8 = 0.0;
   double gauss_herm100 = 0.0;

   gauss_herm2 = (0.5 * exp(-9)) * (gauss_hermitte(func_herm,2));
   gauss_herm4 = (0.5 * exp(-9)) * (gauss_hermitte(func_herm,4));
   gauss_herm8 = (0.5 * exp(-9)) * (gauss_hermitte(func_herm,8));
   gauss_herm100 = (0.5 * exp(-9)) * (gauss_hermitte(func_herm,100));

    cout << "--------------------------------------------------------------- " << endl;

   printf("Gauss Hermite con 2 punti: %.16lf \n", gauss_herm2);
   printf("Gauss Hermite con 4 punti: %.16lf \n", gauss_herm4);
   printf("Gauss Hermite con 8 punti: %.16lf \n", gauss_herm8);
   printf("Gauss Hermite con 100 punti: %.16lf \n", gauss_herm100);

   cout << "--------------------------------------------------------------- " << endl;

   double gauss_lag2 = 0.0;
   double gauss_lag4 = 0.0;
   double gauss_lag8 = 0.0;

   gauss_lag2 = exp(-9) * (gauss_laguerre(func_lag, 2));
   gauss_lag4 = exp(-9) * (gauss_laguerre(func_lag, 4));
   gauss_lag8 = exp(-9) * (gauss_laguerre(func_lag, 8));
   
   printf("Gauss Laguerre con 2 punti: %.16lf \n", gauss_lag2);
   printf("Gauss Laguerre con 4 punti: %.16lf \n", gauss_lag4);
   printf("Gauss Laguerre con 8 punti: %.16lf \n", gauss_lag8);

return 0;
}


