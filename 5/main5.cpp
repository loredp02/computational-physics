
#include <iostream>
#include "stdlib.h"
#include "math.h"
#include <fstream>          
#include <cmath>
#include <vector>
#define FUNC(x) ((*func)(x))
#define nMAX 21


using namespace std;

// Metodo del trapezio 

double trapzd (double (*func)(double), double a, double b, int n){
    double x, tnm, sum, del;
    static double s;
    int it,j;

    if(n==1){ return (s = 0.5*(b-a)*(FUNC(a) + FUNC(b)));
    } else {
        for (it=1, j=1; j < n-1; j++) it <<= 1;
        tnm = it;
        del = (b-a)/tnm;
        x = a + (double) (1./2.)*del;
        for (sum=0.0, j=1; j<=it;j++,x+=del) sum += FUNC(x);
        s= (double) (1./2.) *(s+(b-a)*sum/tnm);  
        return s;
    }
}

// Metodo di Simpson

double qsimp(double (*func)(double), double a, double b, int n){
    int j;
    float s,st,ost=0.0,os=0.0;

    for (j=1;j<=n;j++) {
        st=trapzd(func,a,b,j);
        s=(4.0*st-ost)/3.0;
        os=s;
        ost=st;
    }

    return s;
}

// METODO DI ROMBERG

double romberg(double (*func)(double), double a, double b, int N) {
    double h[N+1], r[N+1][N+1];
    for (int i = 1; i < N + 1; ++i) {
        h[i] = (b - a) / pow(2, i - 1);
    }
    r[1][1] = h[1] / 2 * (func(a) + func(b));
    for (int i = 2; i < N + 1; ++i) {
        double coeff = 0;
        for (int k = 1; k <= pow(2, i - 2); ++k) {
            coeff += func(a + (2 * k - 1) * h[i]);
        }
        r[i][1] = 0.5 * (r[i - 1][1] + h[i - 1] * coeff);
    }
    
    for (int i = 2; i < N + 1; ++i) {
        for (int j = 2; j <= i; ++j) {
            r[i][j] = r[i][j - 1] + (r[i][j - 1] - r[i - 1][j - 1]) / (pow(4, j - 1) - 1);
        }
    }
    return r[N][N];
}

// METODI DI GAUSS 
    
double gauss_legendre(double (*func) (double), double a, double b, int n){
    // Cambiamo l'intervallo di integrazione della funzione tra [-1,1]
    vector<double> vec_x2 {-5.77350269189625764507e-01, 5.77350269189625764507e-01};
    vector<double> vec_x4 {-8.61136311594052575248e-01, -3.39981043584856264792e-01, 3.39981043584856264792e-01, 8.61136311594052575248e-01};
    vector<double> vec_x8 {-9.60289856497536231661e-01, -7.96666477413626739567e-01, -5.25532409916328985830e-01, -1.83434642495649804936e-01,
                            1.83434642495649804936e-01,  5.25532409916328985830e-01, 7.96666477413626739567e-01, 9.60289856497536231661e-01};
    vector<double> vec_x16 {-9.89400934991649932601e-01, -9.44575023073232576090e-01, -8.65631202387831743866e-01, -7.55404408355003033891e-01,
                            -6.17876244402643748452e-01, -4.58016777657227386350e-01, -2.81603550779258913231e-01, -9.50125098376374401877e-02,
                            9.50125098376374401877e-02, 2.81603550779258913231e-01, 4.58016777657227386350e-01, 6.17876244402643748452e-01,
                            7.55404408355003033891e-01, 8.65631202387831743866e-01, 9.44575023073232576090e-01, 9.89400934991649932601e-01};
    vector<double> vec_x48 {-9.98771007252426118580e-01, -9.93530172266350757526e-01, -9.84124583722826857765e-01, -9.70591592546247250472e-01,
                            -9.52987703160430860724e-01, -9.31386690706554333107e-01, -9.05879136715569672805e-01, -8.76572020274247885885e-01,
                            -8.43588261624393530704e-01, -8.07066204029442627087e-01, -7.67159032515740339276e-01, -7.24034130923814654658e-01,
                            -6.77872379632663905208e-01, -6.28867396776513624013e-01, -5.77224726083972703838e-01, -5.23160974722233033658e-01,
                            -4.66902904750958404535e-01, -4.08686481990716729925e-01, -3.48755886292160738148e-01, -2.87362487355455576728e-01,
                            -2.24763790394689061224e-01, -1.61222356068891718055e-01, -9.70046992094626989322e-02, -3.23801709628693620343e-02,
                            3.23801709628693620343e-02, 9.70046992094626989322e-02, 1.61222356068891718055e-01, 2.24763790394689061224e-01,
                            2.87362487355455576728e-01, 3.48755886292160738148e-01, 4.08686481990716729925e-01, 4.66902904750958404535e-01,
                            5.23160974722233033658e-01, 5.77224726083972703838e-01, 6.28867396776513624013e-01, 6.77872379632663905208e-01,
                            7.24034130923814654658e-01, 7.67159032515740339276e-01, 8.07066204029442627087e-01, 8.43588261624393530704e-01,
                            8.76572020274247885885e-01, 9.05879136715569672805e-01, 9.31386690706554333107e-01, 9.52987703160430860724e-01,
                            9.70591592546247250472e-01, 9.84124583722826857765e-01, 9.93530172266350757526e-01, 9.98771007252426118580e-01};

    vector<double> vec_w2 {1, 1};
    vector<double> vec_w4 {3.47854845137453857383e-01, 6.52145154862546142644e-01, 6.52145154862546142644e-01, 3.47854845137453857383e-01};
    vector<double> vec_w8 {1.01228536290376259154e-01, 2.22381034453374470546e-01,  3.13706645877887287338e-01,  3.62683783378361982976e-01,
                           3.62683783378361982976e-01, 3.13706645877887287338e-01,  2.22381034453374470546e-01, 1.01228536290376259154e-01};
    vector<double> vec_w16 {2.71524594117540948514e-02, 6.22535239386478928628e-02, 9.51585116824927848073e-02, 1.24628971255533872056e-01,
                            1.49595988816576732080e-01, 1.69156519395002538183e-01, 1.82603415044923588872e-01, 1.89450610455068496287e-01,
                            1.89450610455068496287e-01, 1.82603415044923588872e-01, 1.69156519395002538183e-01, 1.49595988816576732080e-01,
                            1.24628971255533872056e-01, 9.51585116824927848073e-02, 6.22535239386478928628e-02, 2.71524594117540948514e-02};
    vector<double> vec_w48 {3.15334605230583863260e-03, 7.32755390127626210220e-03, 1.14772345792345394895e-02, 1.55793157229438487279e-02,
                            1.96161604573555278142e-02, 2.35707608393243791410e-02, 2.74265097083569482001e-02, 3.11672278327980889025e-02,
                            3.47772225647704388909e-02, 3.82413510658307063158e-02, 4.15450829434647492133e-02, 4.46745608566942804201e-02,
                            4.76166584924904748267e-02, 5.03590355538544749590e-02, 5.28901894851936670964e-02, 5.51995036999841628676e-02,
                            5.72772921004032157044e-02, 5.91148396983956357477e-02, 6.07044391658938800517e-02, 6.20394231598926639029e-02,
                            6.31141922862540256548e-02, 6.39242385846481866207e-02, 6.44661644359500822082e-02, 6.47376968126839225006e-02,
                            6.47376968126839225006e-02, 6.44661644359500822082e-02, 6.39242385846481866207e-02, 6.31141922862540256548e-02,
                            6.20394231598926639029e-02, 6.07044391658938800517e-02, 5.91148396983956357477e-02, 5.72772921004032157044e-02,
                            5.51995036999841628676e-02, 5.28901894851936670964e-02, 5.03590355538544749590e-02, 4.76166584924904748267e-02,
                            4.46745608566942804201e-02, 4.15450829434647492133e-02, 3.82413510658307063158e-02, 3.47772225647704388909e-02,
                            3.11672278327980889025e-02, 2.74265097083569482001e-02, 2.35707608393243791410e-02, 1.96161604573555278142e-02,
                            1.55793157229438487279e-02, 1.14772345792345394895e-02, 7.32755390127626210220e-03, 3.15334605230583863260e-03};

    double res = 0.0;
    double coeff = (b-a)*(1./2.);
    double sum = 0.0;

    if(n==2){
        for(int i = 0; i < n; i++){
            sum += vec_w2.at(i)*func(coeff*vec_x2.at(i) + (a+b)*(1./2.));
        }
    }

    else if(n==4){
        for(int i = 0; i < n; i++){
            sum += vec_w4.at(i)*func(coeff*vec_x4.at(i) + (a+b)*(1./2.));
        }
    }

    else if(n==8){
        for(int i = 0; i < n; i++){
            sum += vec_w8.at(i)*func(coeff*vec_x8.at(i) + (a+b)*(1./2.));
        }
    }

    else if(n==16){
        for(int i = 0; i < n; i++){
            sum += vec_w16.at(i)*func(coeff*vec_x16.at(i) + (a+b)*(1./2.));
        }
    }

    else if(n==48){
        for(int i = 0; i < n; i++){
            sum += vec_w48.at(i)*func(coeff*vec_x48.at(i) + (a+b)*(1./2.));
        }
    } 


    res = coeff*sum;

    return res;
}



///////////////////////////////////////////////////////////////////////////////////////////////////7

// funzione di base
double func(double x){
    double y = 0.0;
    y = pow(x,2) + x*sin(4*x);
    return y;
}


int main ()
{   
    double a = -1.;
    double b = 8.;
    double TrueRes = 1./16. * (2736 + sin(4) + sin(32) - 4*cos(4) - 32*cos(32));
    printf("Il risultato vero: %.16lf \n", TrueRes);

    
    int n = 0;

    FILE * TRAPDEV = fopen("trapezdev.txt", "w");
    FILE * SIMPDEV = fopen("simpdev.txt", "w");
    FILE * ROMBDEV = fopen("rombdev.txt", "w");


    for(int n = 1; n <= nMAX; n += 1){
        ///////////////////////////////////////////////////////////////////////////////////////// TRAPEZIO
        double TrapezioRis = 0.0;
        TrapezioRis = trapzd(func, a, b, n);
        double TrapezioDev = fabs(TrueRes - TrapezioRis);
        fprintf(TRAPDEV, "%f %.16lf\n", 1./n, TrapezioDev);

        // cout << "Il risultato col trapezio: " << TrapezioRis << "\n" << endl;
        ///////////////////////////////////////////////////////////////////////////////////////// SIMPSON
        double SimpsonRis = 0.0;
        SimpsonRis = qsimp(func, a, b, n);
        double SimpsonDev = fabs(TrueRes - SimpsonRis);
        fprintf(SIMPDEV, "%f %.16lf\n", 1./n, SimpsonDev);
        
        // cout << "Il risultato con Simpson: " << SimpsonRis << "\n" << endl;
        ///////////////////////////////////////////////////////////////////////////////////////// ROMBERG
        double RombergRis = 0.0;
        RombergRis = romberg(func, a, b, n);
        double RombDev = fabs(TrueRes - RombergRis);
        fprintf(ROMBDEV, "%f %.16lf\n", 1./n, RombDev);
        //cout << "romb: " << n << RombergRis << "\n" << endl;
    }

   double gauss_leg2 = 0.0;
   double gauss_leg4 = 0.0;
   double gauss_leg8 = 0.0;
   double gauss_leg16 = 0.0;
   double gauss_leg48 = 0.0;

   gauss_leg2 = gauss_legendre(func, a, b, 2);
   gauss_leg4 = gauss_legendre(func, a, b, 4);
   gauss_leg8 = gauss_legendre(func, a, b, 8);
   gauss_leg16 = gauss_legendre(func, a, b, 16);
   gauss_leg48 = gauss_legendre(func, a, b, 48);

   printf("Gauss Legendre con 2 punti: %.16lf \n", gauss_leg2);
   printf("Gauss Legendre con 4 punti: %.16lf \n", gauss_leg4);
   printf("Gauss Legendre con 8 punti: %.16lf \n", gauss_leg8);
   printf("Gauss Legendre con 16 punti: %.16lf \n", gauss_leg16);
   printf("Gauss Legendre con 48 punti: %.16lf \n", gauss_leg48);


return 0;
}


